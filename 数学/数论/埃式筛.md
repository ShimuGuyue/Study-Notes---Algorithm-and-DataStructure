# 埃式筛

埃式筛是一种高效筛选出指定范围内的全部素数的算法。

由于质数的倍数（不含本身）一定是合数，所以从 $2$ 开始遍历所有数，如果遇到一个质数，将他的所有倍数标记为合数。

如果有一个数在遍历过程中没有被标记为合数，说明比他小的数里面没有他的因数，这个数是质数。

根据梅滕斯第二定理，该算法的时间复杂度为 $O(n \ln(\ln n))$，稍逊于线性筛的 $O(n)$，但在 $10 ^ 7$ 数据范围内差距很小，且代码量更简短。

**优化一**：对于任意 $a \times b = c,\ a > b$，在 $c$ 被 $a$ 标记之前一定已经被 $b$ 标记过，因此遍历 $a$ 的倍数时从 $a ^ 2$ 开始即可。

**优化二**：除 $2$ 以外的所有偶数均为合数，除 $2$ 以外的质数只会出现在奇数中，因此只需要遍历每个质数的奇数倍即可。

## 模板

```cpp
std::pair<std::vector<int>, std::vector<bool>> eratosthenes(const int n)
{
    std::pair<std::vector<int>, std::vector<bool>> ans;
    auto& [primes, is_primes]{ ans };

    primes.reserve(n / std::log(n));
    is_primes.assign(n + 1, true);

    is_primes[0] = false;
    is_primes[1] = false;

    int i{ 2 };
    while (i <= n)
    {
        if (is_primes[i])
        {
            primes.push_back(i);
            if (int64_t(i) * i > n)
                continue;
            int step{ i == 2 ? i : i * 2 };
            for (int j{i * i}; j <= n; j += step)
            {
                is_primes[j] = false;
            }
        }
        if (i == 2)
            i += 1;
        else
            i += 2;
    }

    return ans;
}
```

